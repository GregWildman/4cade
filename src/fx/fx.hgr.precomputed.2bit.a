;license:MIT
;(c) 2019-2022 by 4am
;

;hgrlo          = $0201    ; $C0 bytes (defined in constants.a)
mirror_cols    = $02C1    ; $28 bytes
;hgr1hi         = $0301    ; $C0 bytes (defined in constants.a)
dithermasks    = $BDA8    ; $58 bytes
evenrow_masks  = dithermasks
oddrow_masks   = dithermasks+2
no_masks       = dithermasks+44
copymasks      = $BE00    ; $100 bytes but sparse, index is 0..4 but in high 3 bits, so $00, $20, $40, $60, $80
mirror_copymasks = copymasks+1

         !source "src/fx/macros.a"

!macro BUILD_SPARSE_BITMASKS_2BIT .copymasks, .mirror_copymasks {
         ; build sparse lookup tables for bitmasks
         lda   #%10000011
         sta   .copymasks
         sta   .mirror_copymasks+$E0

         lda   #%10001100
         sta   .copymasks+$20
         sta   .mirror_copymasks+$C0

         lda   #%10110000
         sta   .copymasks+$40
         sta   .mirror_copymasks+$A0

         lda   #%11000000
         sta   .copymasks+$60
         sta   .mirror_copymasks+$80

         lda   #%10000001
         sta   .copymasks+$80
         sta   .mirror_copymasks+$60

         lda   #%10000110
         sta   .copymasks+$A0
         sta   .mirror_copymasks+$40

         lda   #%10011000
         sta   .copymasks+$C0
         sta   .mirror_copymasks+$20

         lda   #%11100000
         sta   .copymasks+$E0
         sta   .mirror_copymasks
}

!macro ROW_X_TO_2BIT_BASE_ADDRESSES {
         ; X = $01..$C0, mapping to row 0..191
         lda   hgrlo-1, x
         sta   <dest1
         sta   <src1
         lda   hgr1hi-1, x
         sta   <dest1+1
         eor   #$60
         sta   <src1+1
         lda   hgrlo, x
         sta   <dest2
         sta   <src2
         lda   hgr1hi, x
         sta   <dest2+1
         eor   #$60
         sta   <src2+1
}

!macro FX_INITONCE_2BIT .CoordinatesFile, .Start {
InitOnce
         bit   .Start
         lda   #$4C
         sta   InitOnce

         +LDADDR .CoordinatesFile
         ldx   #>Coordinates2Bit
         jsr   iLoadFXDATA

         lda   #$00
         sta   EndCoordinates2Bit
}

!macro FX_PRECOMPUTED_2BIT .coords {
         jsr   iBuildHGRTables
         +BUILD_MIRROR_COLS mirror_cols
         +BUILD_SPARSE_BITMASKS_2BIT copymasks, mirror_copymasks
         +COPY_TO_0 start, end
         jmp   InputLoop
start
!pseudopc 0 {
Exit2Bit rts
InputLoop
         ldy   #0
input=*+1
         ldx   .coords               ; first value: HGR row + 1
         beq   Exit2Bit              ; if 0 then we're done
         +ROW_X_TO_2BIT_BASE_ADDRESSES

         inc   <input
         lda   (<input), y
         +HIGH_3_LOW_5 input

         ; main 2x2 block in left half
src1=*+1
         lda   $FDFD, y
         eor   (<dest1), y
         and   copymasks, x
         eor   (<dest1), y
dest1=*+1
         sta   $FDFD, y
src2=*+1
         lda   $FDFD, y
         eor   (<dest2), y
         and   copymasks, x
         eor   (<dest2), y
dest2=*+1
         sta   $FDFD, y

         ; corresponding 2x2 block in right half (same row, opposite column)
         lda   mirror_cols, y
         tay
         +COPY_BIT src1, dest1, mirror_copymasks
         +COPY_BIT src2, dest2, mirror_copymasks

         inc   <input
         bne   InputLoop
         bit   KBD
         bmi   Exit2Bit
         inc   <input+1
         bne   InputLoop             ; always branches
}
end
}

!macro FX_PRECOMPUTED_2BIT_DITHER .coords, .endcoords {
         +BUILD_DITHER_MASKS dithermasks
         jsr   iBuildHGRTables
         +BUILD_MIRROR_COLS mirror_cols
         +BUILD_SPARSE_BITMASKS_2BIT copymasks, mirror_copymasks

         ; phase 1 - in reverse, with additional masking (dithering)
         jsr   copytozp

         ; set up starting coordinate for reading coordinates in reverse order
         +LDADDR .endcoords-2
         sta   <input
         sty   <input+1

         ; set up EOF marker to stop reading coordinates in reverse order
         lda   #$00
         sta   .coords-2

         ; set up logic to advance to next coordinates in reverse order
         ldx   #(next2_end-next2_start-1)
-        lda   next2_start, x
         sta   <next, x
         dex
         bpl   -

         jsr   InputLoop

         bit   KBD
         bmi   start

         ; phase 2 - in order, without additional masking
         jsr   copytozp

         ; redirect additional masking pointers to an array that contains #$FFs (so no dithering)
         lda   #<no_masks
         sta   <evenrow_ptr
         sta   <oddrow_ptr

         jmp   InputLoop

copytozp
         +COPY_TO_0 start, end
start
!pseudopc 0 {
Exit2Bit rts
evenrow_ptr
         !word evenrow_masks
oddrow_ptr
         !word oddrow_masks
InputLoop
         ldy   #0
input=*+1
         ldx   .coords               ; first value: HGR row + 1
         beq   Exit2Bit              ; if 0 then we're done
         +ROW_X_TO_2BIT_BASE_ADDRESSES

         iny
         lda   (<input), y
         +HIGH_3_LOW_5 input

         ; main 2x2 block in left half
src1=*+1
         lda   $FDFD, y
         eor   (<dest1), y
         and   copymasks, x
         and   (<evenrow_ptr), y
         eor   (<dest1), y
dest1=*+1
         sta   $FDFD, y
src2=*+1
         lda   $FDFD, y
         eor   (<dest2), y
         and   copymasks, x
         and   (<oddrow_ptr), y
         eor   (<dest2), y
dest2=*+1
         sta   $FDFD, y

         ; corresponding 2x2 block in right half (same row, opposite column)
         lda   mirror_cols, y
         tay
         lda   (src1), y
         eor   (dest1), y
         and   mirror_copymasks, x
         and   (<evenrow_ptr), y
         eor   (dest1), y
         sta   (dest1), y

         lda   (src2), y
         eor   (dest2), y
         and   mirror_copymasks, x
         and   (<oddrow_ptr), y
         eor   (dest2), y
         sta   (dest2), y

next
         inc   <input
         inc   <input
         bne   InputLoop
         bit   KBD
         bmi   Exit2Bit
         inc   <input+1
         bne   InputLoop             ; always branches
}
end

next2_start
!pseudopc next {
         lda   <input
         php
         dec   <input
         dec   <input
         plp
         bne   InputLoop
         dec   <input+1
         bit   KBD
         bpl   InputLoop
         rts
}
next2_end
}
